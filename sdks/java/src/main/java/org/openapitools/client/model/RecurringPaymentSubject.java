/*
 * Tebex Checkout API
 * The Checkout APIs are designed to allow our creators to use the Tebex Checkout flow and payment acceptance capabilities without the need to set up a Tebex-powered webstore. Using these APIs allows you to create baskets with custom products (as opposed to pre-created products on our webstore platform), and send customers directly to the checkout flow to proceed with payment options.  You must receive prior authorisation before the Checkout API is enabled on your account. Please contact customer support or your account manager to discover if you qualify to use the Checkout API before beginning integration.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: tebex-integrations@overwolf.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.PaymentSubject;
import org.openapitools.client.model.RecurringPaymentSubjectPrice;
import org.openapitools.client.model.RecurringPaymentSubjectStatus;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import TebexCheckout.JSON;

/**
 * RecurringPaymentSubject
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-07-08T10:31:44.004464-05:00[America/Chicago]", comments = "Generator version: 7.5.0")
public class RecurringPaymentSubject {
  public static final String SERIALIZED_NAME_REFERENCE = "reference";
  @SerializedName(SERIALIZED_NAME_REFERENCE)
  private String reference;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_PAUSED_AT = "paused_at";
  @SerializedName(SERIALIZED_NAME_PAUSED_AT)
  private OffsetDateTime pausedAt;

  public static final String SERIALIZED_NAME_PAUSED_UNTIL = "paused_until";
  @SerializedName(SERIALIZED_NAME_PAUSED_UNTIL)
  private OffsetDateTime pausedUntil;

  public static final String SERIALIZED_NAME_NEXT_PAYMENT_AT = "next_payment_at";
  @SerializedName(SERIALIZED_NAME_NEXT_PAYMENT_AT)
  private OffsetDateTime nextPaymentAt;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private RecurringPaymentSubjectStatus status;

  public static final String SERIALIZED_NAME_INITIAL_PAYMENT = "initial_payment";
  @SerializedName(SERIALIZED_NAME_INITIAL_PAYMENT)
  private PaymentSubject initialPayment;

  public static final String SERIALIZED_NAME_LAST_PAYMENT = "last_payment";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT)
  private PaymentSubject lastPayment;

  public static final String SERIALIZED_NAME_FAIL_COUNT = "fail_count";
  @SerializedName(SERIALIZED_NAME_FAIL_COUNT)
  private Integer failCount;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  private RecurringPaymentSubjectPrice price;

  public static final String SERIALIZED_NAME_CANCELLED_AT = "cancelled_at";
  @SerializedName(SERIALIZED_NAME_CANCELLED_AT)
  private OffsetDateTime cancelledAt;

  public static final String SERIALIZED_NAME_CANCEL_REASON = "cancel_reason";
  @SerializedName(SERIALIZED_NAME_CANCEL_REASON)
  private String cancelReason;

  public RecurringPaymentSubject() {
  }

  public RecurringPaymentSubject reference(String reference) {
    this.reference = reference;
    return this;
  }

   /**
   * Get reference
   * @return reference
  **/
  @javax.annotation.Nullable
  public String getReference() {
    return reference;
  }

  public void setReference(String reference) {
    this.reference = reference;
  }


  public RecurringPaymentSubject createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Get createdAt
   * @return createdAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public RecurringPaymentSubject pausedAt(OffsetDateTime pausedAt) {
    this.pausedAt = pausedAt;
    return this;
  }

   /**
   * Get pausedAt
   * @return pausedAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getPausedAt() {
    return pausedAt;
  }

  public void setPausedAt(OffsetDateTime pausedAt) {
    this.pausedAt = pausedAt;
  }


  public RecurringPaymentSubject pausedUntil(OffsetDateTime pausedUntil) {
    this.pausedUntil = pausedUntil;
    return this;
  }

   /**
   * Get pausedUntil
   * @return pausedUntil
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getPausedUntil() {
    return pausedUntil;
  }

  public void setPausedUntil(OffsetDateTime pausedUntil) {
    this.pausedUntil = pausedUntil;
  }


  public RecurringPaymentSubject nextPaymentAt(OffsetDateTime nextPaymentAt) {
    this.nextPaymentAt = nextPaymentAt;
    return this;
  }

   /**
   * Get nextPaymentAt
   * @return nextPaymentAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getNextPaymentAt() {
    return nextPaymentAt;
  }

  public void setNextPaymentAt(OffsetDateTime nextPaymentAt) {
    this.nextPaymentAt = nextPaymentAt;
  }


  public RecurringPaymentSubject status(RecurringPaymentSubjectStatus status) {
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nullable
  public RecurringPaymentSubjectStatus getStatus() {
    return status;
  }

  public void setStatus(RecurringPaymentSubjectStatus status) {
    this.status = status;
  }


  public RecurringPaymentSubject initialPayment(PaymentSubject initialPayment) {
    this.initialPayment = initialPayment;
    return this;
  }

   /**
   * Get initialPayment
   * @return initialPayment
  **/
  @javax.annotation.Nullable
  public PaymentSubject getInitialPayment() {
    return initialPayment;
  }

  public void setInitialPayment(PaymentSubject initialPayment) {
    this.initialPayment = initialPayment;
  }


  public RecurringPaymentSubject lastPayment(PaymentSubject lastPayment) {
    this.lastPayment = lastPayment;
    return this;
  }

   /**
   * Get lastPayment
   * @return lastPayment
  **/
  @javax.annotation.Nullable
  public PaymentSubject getLastPayment() {
    return lastPayment;
  }

  public void setLastPayment(PaymentSubject lastPayment) {
    this.lastPayment = lastPayment;
  }


  public RecurringPaymentSubject failCount(Integer failCount) {
    this.failCount = failCount;
    return this;
  }

   /**
   * Get failCount
   * @return failCount
  **/
  @javax.annotation.Nullable
  public Integer getFailCount() {
    return failCount;
  }

  public void setFailCount(Integer failCount) {
    this.failCount = failCount;
  }


  public RecurringPaymentSubject price(RecurringPaymentSubjectPrice price) {
    this.price = price;
    return this;
  }

   /**
   * Get price
   * @return price
  **/
  @javax.annotation.Nullable
  public RecurringPaymentSubjectPrice getPrice() {
    return price;
  }

  public void setPrice(RecurringPaymentSubjectPrice price) {
    this.price = price;
  }


  public RecurringPaymentSubject cancelledAt(OffsetDateTime cancelledAt) {
    this.cancelledAt = cancelledAt;
    return this;
  }

   /**
   * Get cancelledAt
   * @return cancelledAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCancelledAt() {
    return cancelledAt;
  }

  public void setCancelledAt(OffsetDateTime cancelledAt) {
    this.cancelledAt = cancelledAt;
  }


  public RecurringPaymentSubject cancelReason(String cancelReason) {
    this.cancelReason = cancelReason;
    return this;
  }

   /**
   * Get cancelReason
   * @return cancelReason
  **/
  @javax.annotation.Nullable
  public String getCancelReason() {
    return cancelReason;
  }

  public void setCancelReason(String cancelReason) {
    this.cancelReason = cancelReason;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RecurringPaymentSubject recurringPaymentSubject = (RecurringPaymentSubject) o;
    return Objects.equals(this.reference, recurringPaymentSubject.reference) &&
        Objects.equals(this.createdAt, recurringPaymentSubject.createdAt) &&
        Objects.equals(this.pausedAt, recurringPaymentSubject.pausedAt) &&
        Objects.equals(this.pausedUntil, recurringPaymentSubject.pausedUntil) &&
        Objects.equals(this.nextPaymentAt, recurringPaymentSubject.nextPaymentAt) &&
        Objects.equals(this.status, recurringPaymentSubject.status) &&
        Objects.equals(this.initialPayment, recurringPaymentSubject.initialPayment) &&
        Objects.equals(this.lastPayment, recurringPaymentSubject.lastPayment) &&
        Objects.equals(this.failCount, recurringPaymentSubject.failCount) &&
        Objects.equals(this.price, recurringPaymentSubject.price) &&
        Objects.equals(this.cancelledAt, recurringPaymentSubject.cancelledAt) &&
        Objects.equals(this.cancelReason, recurringPaymentSubject.cancelReason);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(reference, createdAt, pausedAt, pausedUntil, nextPaymentAt, status, initialPayment, lastPayment, failCount, price, cancelledAt, cancelReason);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RecurringPaymentSubject {\n");
    sb.append("    reference: ").append(toIndentedString(reference)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    pausedAt: ").append(toIndentedString(pausedAt)).append("\n");
    sb.append("    pausedUntil: ").append(toIndentedString(pausedUntil)).append("\n");
    sb.append("    nextPaymentAt: ").append(toIndentedString(nextPaymentAt)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    initialPayment: ").append(toIndentedString(initialPayment)).append("\n");
    sb.append("    lastPayment: ").append(toIndentedString(lastPayment)).append("\n");
    sb.append("    failCount: ").append(toIndentedString(failCount)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    cancelledAt: ").append(toIndentedString(cancelledAt)).append("\n");
    sb.append("    cancelReason: ").append(toIndentedString(cancelReason)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("reference");
    openapiFields.add("created_at");
    openapiFields.add("paused_at");
    openapiFields.add("paused_until");
    openapiFields.add("next_payment_at");
    openapiFields.add("status");
    openapiFields.add("initial_payment");
    openapiFields.add("last_payment");
    openapiFields.add("fail_count");
    openapiFields.add("price");
    openapiFields.add("cancelled_at");
    openapiFields.add("cancel_reason");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to RecurringPaymentSubject
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RecurringPaymentSubject.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RecurringPaymentSubject is not found in the empty JSON string", RecurringPaymentSubject.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RecurringPaymentSubject.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RecurringPaymentSubject` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("reference") != null && !jsonObj.get("reference").isJsonNull()) && !jsonObj.get("reference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reference").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        RecurringPaymentSubjectStatus.validateJsonElement(jsonObj.get("status"));
      }
      // validate the optional field `initial_payment`
      if (jsonObj.get("initial_payment") != null && !jsonObj.get("initial_payment").isJsonNull()) {
        PaymentSubject.validateJsonElement(jsonObj.get("initial_payment"));
      }
      // validate the optional field `last_payment`
      if (jsonObj.get("last_payment") != null && !jsonObj.get("last_payment").isJsonNull()) {
        PaymentSubject.validateJsonElement(jsonObj.get("last_payment"));
      }
      // validate the optional field `price`
      if (jsonObj.get("price") != null && !jsonObj.get("price").isJsonNull()) {
        RecurringPaymentSubjectPrice.validateJsonElement(jsonObj.get("price"));
      }
      if ((jsonObj.get("cancel_reason") != null && !jsonObj.get("cancel_reason").isJsonNull()) && !jsonObj.get("cancel_reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancel_reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancel_reason").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RecurringPaymentSubject.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RecurringPaymentSubject' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RecurringPaymentSubject> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RecurringPaymentSubject.class));

       return (TypeAdapter<T>) new TypeAdapter<RecurringPaymentSubject>() {
           @Override
           public void write(JsonWriter out, RecurringPaymentSubject value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RecurringPaymentSubject read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RecurringPaymentSubject given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RecurringPaymentSubject
  * @throws IOException if the JSON string is invalid with respect to RecurringPaymentSubject
  */
  public static RecurringPaymentSubject fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RecurringPaymentSubject.class);
  }

 /**
  * Convert an instance of RecurringPaymentSubject to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

