/*
 * Tebex Checkout API
 * The Checkout APIs are designed to allow our creators to use the Tebex Checkout flow and payment acceptance capabilities without the need to set up a Tebex-powered webstore. Using these APIs allows you to create baskets with custom products (as opposed to pre-created products on our webstore platform), and send customers directly to the checkout flow to proceed with payment options.  You must receive prior authorisation before the Checkout API is enabled on your account. Please contact customer support or your account manager to discover if you qualify to use the Checkout API before beginning integration.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: tebex-integrations@overwolf.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package TebexCheckout;

import TebexCheckout.ApiCallback;
import TebexCheckout.ApiClient;
import TebexCheckout.ApiException;
import TebexCheckout.ApiResponse;
import TebexCheckout.Configuration;
import TebexCheckout.Pair;
import TebexCheckout.ProgressRequestBody;
import TebexCheckout.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.RecurringPayment;
import org.openapitools.client.model.UpdateRecurringPaymentRequest;
import org.openapitools.client.model.UpdateSubscriptionRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RecurringPaymentsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RecurringPaymentsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RecurringPaymentsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for cancelRecurringPayment
     * @param reference The recurring payment reference to cancel. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Recurring payment cancelled successfully. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelRecurringPaymentCall(String reference, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/recurring-payments/{reference}"
            .replace("{" + "reference" + "}", localVarApiClient.escapeString(reference.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "tebex_checkout_auth_basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelRecurringPaymentValidateBeforeCall(String reference, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reference' is set
        if (reference == null) {
            throw new ApiException("Missing the required parameter 'reference' when calling cancelRecurringPayment(Async)");
        }

        return cancelRecurringPaymentCall(reference, _callback);

    }

    /**
     * Cancel a recurring payment
     * This cancels the recurring payment for the reference provided. Recurring payment references start with &#x60;tbx-r-&#x60;
     * @param reference The recurring payment reference to cancel. (required)
     * @return RecurringPayment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Recurring payment cancelled successfully. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public RecurringPayment cancelRecurringPayment(String reference) throws ApiException {
        ApiResponse<RecurringPayment> localVarResp = cancelRecurringPaymentWithHttpInfo(reference);
        return localVarResp.getData();
    }

    /**
     * Cancel a recurring payment
     * This cancels the recurring payment for the reference provided. Recurring payment references start with &#x60;tbx-r-&#x60;
     * @param reference The recurring payment reference to cancel. (required)
     * @return ApiResponse&lt;RecurringPayment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Recurring payment cancelled successfully. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecurringPayment> cancelRecurringPaymentWithHttpInfo(String reference) throws ApiException {
        okhttp3.Call localVarCall = cancelRecurringPaymentValidateBeforeCall(reference, null);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cancel a recurring payment (asynchronously)
     * This cancels the recurring payment for the reference provided. Recurring payment references start with &#x60;tbx-r-&#x60;
     * @param reference The recurring payment reference to cancel. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Recurring payment cancelled successfully. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cancelRecurringPaymentAsync(String reference, final ApiCallback<RecurringPayment> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelRecurringPaymentValidateBeforeCall(reference, _callback);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecurringPayment
     * @param reference The recurring payment reference to fetch. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully fetched recurring payment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecurringPaymentCall(String reference, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/recurring-payments/{reference}"
            .replace("{" + "reference" + "}", localVarApiClient.escapeString(reference.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "tebex_checkout_auth_basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecurringPaymentValidateBeforeCall(String reference, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reference' is set
        if (reference == null) {
            throw new ApiException("Missing the required parameter 'reference' when calling getRecurringPayment(Async)");
        }

        return getRecurringPaymentCall(reference, _callback);

    }

    /**
     * Fetch a recurring payment (subscription) by its reference
     * 
     * @param reference The recurring payment reference to fetch. (required)
     * @return RecurringPayment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully fetched recurring payment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public RecurringPayment getRecurringPayment(String reference) throws ApiException {
        ApiResponse<RecurringPayment> localVarResp = getRecurringPaymentWithHttpInfo(reference);
        return localVarResp.getData();
    }

    /**
     * Fetch a recurring payment (subscription) by its reference
     * 
     * @param reference The recurring payment reference to fetch. (required)
     * @return ApiResponse&lt;RecurringPayment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully fetched recurring payment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecurringPayment> getRecurringPaymentWithHttpInfo(String reference) throws ApiException {
        okhttp3.Call localVarCall = getRecurringPaymentValidateBeforeCall(reference, null);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch a recurring payment (subscription) by its reference (asynchronously)
     * 
     * @param reference The recurring payment reference to fetch. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully fetched recurring payment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecurringPaymentAsync(String reference, final ApiCallback<RecurringPayment> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecurringPaymentValidateBeforeCall(reference, _callback);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateRecurringPayment
     * @param reference The recurring payment reference to update. (required)
     * @param updateRecurringPaymentRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully paused or reactivated a payment. The &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessible Entity. An invalid status was provided or the recurring payment cannot be processed. See ErrorResponse. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateRecurringPaymentCall(String reference, UpdateRecurringPaymentRequest updateRecurringPaymentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRecurringPaymentRequest;

        // create path and map variables
        String localVarPath = "/recurring-payments/{reference}/status"
            .replace("{" + "reference" + "}", localVarApiClient.escapeString(reference.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "tebex_checkout_auth_basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateRecurringPaymentValidateBeforeCall(String reference, UpdateRecurringPaymentRequest updateRecurringPaymentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reference' is set
        if (reference == null) {
            throw new ApiException("Missing the required parameter 'reference' when calling updateRecurringPayment(Async)");
        }

        return updateRecurringPaymentCall(reference, updateRecurringPaymentRequest, _callback);

    }

    /**
     * Pause or reactivate a recurring payment
     * 
     * @param reference The recurring payment reference to update. (required)
     * @param updateRecurringPaymentRequest  (optional)
     * @return RecurringPayment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully paused or reactivated a payment. The &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessible Entity. An invalid status was provided or the recurring payment cannot be processed. See ErrorResponse. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public RecurringPayment updateRecurringPayment(String reference, UpdateRecurringPaymentRequest updateRecurringPaymentRequest) throws ApiException {
        ApiResponse<RecurringPayment> localVarResp = updateRecurringPaymentWithHttpInfo(reference, updateRecurringPaymentRequest);
        return localVarResp.getData();
    }

    /**
     * Pause or reactivate a recurring payment
     * 
     * @param reference The recurring payment reference to update. (required)
     * @param updateRecurringPaymentRequest  (optional)
     * @return ApiResponse&lt;RecurringPayment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully paused or reactivated a payment. The &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessible Entity. An invalid status was provided or the recurring payment cannot be processed. See ErrorResponse. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecurringPayment> updateRecurringPaymentWithHttpInfo(String reference, UpdateRecurringPaymentRequest updateRecurringPaymentRequest) throws ApiException {
        okhttp3.Call localVarCall = updateRecurringPaymentValidateBeforeCall(reference, updateRecurringPaymentRequest, null);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Pause or reactivate a recurring payment (asynchronously)
     * 
     * @param reference The recurring payment reference to update. (required)
     * @param updateRecurringPaymentRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully paused or reactivated a payment. The &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessible Entity. An invalid status was provided or the recurring payment cannot be processed. See ErrorResponse. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateRecurringPaymentAsync(String reference, UpdateRecurringPaymentRequest updateRecurringPaymentRequest, final ApiCallback<RecurringPayment> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateRecurringPaymentValidateBeforeCall(reference, updateRecurringPaymentRequest, _callback);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSubscription
     * @param reference The recurring payment reference to fetch. (required)
     * @param updateSubscriptionRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully updated subscription. The updated &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSubscriptionCall(String reference, UpdateSubscriptionRequest updateSubscriptionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateSubscriptionRequest;

        // create path and map variables
        String localVarPath = "/recurring-payments/{reference}"
            .replace("{" + "reference" + "}", localVarApiClient.escapeString(reference.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "tebex_checkout_auth_basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSubscriptionValidateBeforeCall(String reference, UpdateSubscriptionRequest updateSubscriptionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'reference' is set
        if (reference == null) {
            throw new ApiException("Missing the required parameter 'reference' when calling updateSubscription(Async)");
        }

        return updateSubscriptionCall(reference, updateSubscriptionRequest, _callback);

    }

    /**
     * Update a subscription with a new product / amount to pay - replacing the existing product
     * If the new subscription amount is higher than the existing amount, a pro-rata charge will be made to cover the cost of the new price up until the next billing date.   **This endpoint requires prior approval - please contact your account manager.**
     * @param reference The recurring payment reference to fetch. (required)
     * @param updateSubscriptionRequest  (optional)
     * @return RecurringPayment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully updated subscription. The updated &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public RecurringPayment updateSubscription(String reference, UpdateSubscriptionRequest updateSubscriptionRequest) throws ApiException {
        ApiResponse<RecurringPayment> localVarResp = updateSubscriptionWithHttpInfo(reference, updateSubscriptionRequest);
        return localVarResp.getData();
    }

    /**
     * Update a subscription with a new product / amount to pay - replacing the existing product
     * If the new subscription amount is higher than the existing amount, a pro-rata charge will be made to cover the cost of the new price up until the next billing date.   **This endpoint requires prior approval - please contact your account manager.**
     * @param reference The recurring payment reference to fetch. (required)
     * @param updateSubscriptionRequest  (optional)
     * @return ApiResponse&lt;RecurringPayment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully updated subscription. The updated &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecurringPayment> updateSubscriptionWithHttpInfo(String reference, UpdateSubscriptionRequest updateSubscriptionRequest) throws ApiException {
        okhttp3.Call localVarCall = updateSubscriptionValidateBeforeCall(reference, updateSubscriptionRequest, null);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a subscription with a new product / amount to pay - replacing the existing product (asynchronously)
     * If the new subscription amount is higher than the existing amount, a pro-rata charge will be made to cover the cost of the new price up until the next billing date.   **This endpoint requires prior approval - please contact your account manager.**
     * @param reference The recurring payment reference to fetch. (required)
     * @param updateSubscriptionRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successfully updated subscription. The updated &#x60;RecurringPayment&#x60; is returned. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Recurring payment not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSubscriptionAsync(String reference, UpdateSubscriptionRequest updateSubscriptionRequest, final ApiCallback<RecurringPayment> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSubscriptionValidateBeforeCall(reference, updateSubscriptionRequest, _callback);
        Type localVarReturnType = new TypeToken<RecurringPayment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
